--region aw api
--local variables for API. Automatically generated by https://github.com/simpleavaster/gslua/blob/master/authors/sapphyrus/generate_api.lua
--I only made a little change to make him work for aimware
local entities_GetPlayerResources, entities_FindByClass, entities_GetByIndex, entities_GetLocalPlayer, entities_GetByUserID =
    entities.GetPlayerResources,
    entities.FindByClass,
    entities.GetByIndex,
    entities.GetLocalPlayer,
    entities.GetByUserID
local client_GetLocalPlayerIndex,
    client_ChatSay,
    client_WorldToScreen,
    client_Command,
    client_GetPlayerIndexByUserID,
    client_SetConVar,
    client_GetPlayerInfo,
    client_GetConVar =
    client.GetLocalPlayerIndex,
    client.ChatSay,
    client.WorldToScreen,
    client.Command,
    client.GetPlayerIndexByUserID,
    client.SetConVar,
    client.GetPlayerInfo,
    client.GetConVar
local client_GetPlayerNameByIndex, client_GetPlayerNameByUserID, client_ChatTeamSay, client_AllowListener =
    client.GetPlayerNameByIndex,
    client.GetPlayerNameByUserID,
    client.ChatTeamSay,
    client.AllowListener
local globals_FrameTime,
    globals_AbsoluteFrameTime,
    globals_CurTime,
    globals_TickCount,
    globals_MaxClients,
    globals_RealTime,
    globals_FrameCount,
    globals_TickInterval =
    globals.FrameTime,
    globals.AbsoluteFrameTime,
    globals.CurTime,
    globals.TickCount,
    globals.MaxClients,
    globals.RealTime,
    globals.FrameCount,
    globals.TickInterval
local http_Get = http.Get
local math_ceil,
    math_tan,
    math_huge,
    math_log10,
    math_randomseed,
    math_cos,
    math_sinh,
    math_random,
    math_mod,
    math_pi,
    math_max,
    math_atan2,
    math_ldexp,
    math_floor,
    math_sqrt,
    math_deg,
    math_atan =
    math.ceil,
    math.tan,
    math.huge,
    math.log10,
    math.randomseed,
    math.cos,
    math.sinh,
    math.random,
    math.mod,
    math.pi,
    math.max,
    math.atan2,
    math.ldexp,
    math.floor,
    math.sqrt,
    math.deg,
    math.atan
local math_fmod,
    math_acos,
    math_pow,
    math_abs,
    math_min,
    math_log,
    math_frexp,
    math_sin,
    math_tanh,
    math_exp,
    math_modf,
    math_cosh,
    math_asin,
    math_rad =
    math.fmod,
    math.acos,
    math.pow,
    math.abs,
    math.min,
    math.log,
    math.frexp,
    math.sin,
    math.tanh,
    math.exp,
    math.modf,
    math.cosh,
    math.asin,
    math.rad
local table_foreach, table_sort, table_remove, table_foreachi, table_maxn, table_getn, table_concat, table_insert =
    table.foreach,
    table.sort,
    table.remove,
    table.foreachi,
    table.maxn,
    table.getn,
    table.concat,
    table.insert
local string_find,
    string_lower,
    string_format,
    string_rep,
    string_gsub,
    string_len,
    string_gmatch,
    string_dump,
    string_match,
    string_reverse,
    string_byte,
    string_char,
    string_upper,
    string_gfind,
    string_sub =
    string.find,
    string.lower,
    string.format,
    string.rep,
    string.gsub,
    string.len,
    string.gmatch,
    string.dump,
    string.match,
    string.reverse,
    string.byte,
    string.char,
    string.upper,
    string.gfind,
    string.sub
--endregion

local hit_effects = true
local hit_group = nil
local hit_love = nil

local hit_group_to_box = {2, 0, 4, 2, 13, 14, 7, 8, 1}

local table_player_historys = {}
local table_active_hits = {}
local table_impacts = {}

local lp = entities_GetLocalPlayer()

local Hit = {
    damage = 0,
    pos = {},
    skeletonvecs = {},
    textpos = {},
    textvel = {},
    liferemaining = 0,
    stacked = 1
}

function Hit:create(damage, hit_group, hit_pos, skeleton_vecs, text_vel)
    local newHit = {}
    setmetatable(newHit, {__index = Hit})
    newHit.damage = damage
    newHit.hitgroup = hit_group
    newHit.pos = hit_pos
    newHit.skeletonvecs = skeleton_vecs
    newHit.textpos = hit_pos
    newHit.textvel = text_vel
    newHit.liferemaining = 3
    newHit.stacked = 1
    return newHit
end

local function vector2(x, y)
    return {x = x, y = y}
end

local function random_vector(ang)
    local rand = math_rad(math_random(270 + ang / 2, 270 - ang / 2))
    local vec = vector2(math_cos(rand), math_sin(rand))
    vec.x = vec.x
    vec.y = vec.y
    return vec
end

local function map(src, src_max, src_min, ret_max, ret_min)
    return (src - src_min) / (src_max - src_min) * (ret_max - ret_min) + ret_min
end

local function get_closest_impact(vec3)
    local best_impact
    local best_distance = math_huge

    for i = 1, #table_impacts do
        if table_impacts[i] then
            local delta = table_impacts[i] - vec3
            local distance = delta:Length()

            if distance < best_distance then
                best_distance = distance
                best_impact = table_impacts[i]
            end
        end
    end

    return best_impact
end

local function get_closest_back_track(point, index, hitbox)
    local best_index
    local best_distance = math_huge

    for i = 1, #table_player_historys[index] do
        if table_player_historys[index][i] then
            local vecs = table_player_historys[index][i].skeleton
            local pos = vecs[hitbox + 1]

            if pos then
                local delta = pos - point
                local distance = delta:Length()

                if distance <= best_distance then
                    best_distance = distance
                    best_index = i
                end
            end
        end
    end

    return table_player_historys[index][best_index].skeleton
end

local renderer = {}

renderer.rectangle = function(x, y, w, h, clr, fill, radius)
    local alpha = 255
    if clr[4] then
        alpha = clr[4]
    end
    draw.Color(clr[1], clr[2], clr[3], alpha)
    if fill then
        draw.FilledRect(x, y, x + w, y + h)
    else
        draw.OutlinedRect(x, y, x + w, y + h)
    end
    if fill == "s" then
        draw.ShadowRect(x, y, x + w, y + h, radius)
    end
end

renderer.love = function(x, y, color)
    renderer.rectangle(x + 2, y + 14, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x, y + 12, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x - 2, y + 10, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x - 4, y + 4, 2, 6, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x - 2, y + 2, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x, y, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 2, y, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 4, y + 2, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 6, y, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 8, y, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 10, y + 2, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 12, y + 4, 2, 6, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 10, y + 10, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 8, y + 12, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 6, y + 14, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x + 4, y + 16, 2, 2, {0, 0, 0, color[4]}, true)
    renderer.rectangle(x - 2, y + 4, 2, 6, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x, y + 2, 4, 2, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x, y + 6, 4, 6, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 2, y + 4, 2, 2, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 2, y + 12, 2, 2, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 4, y + 4, 2, 12, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 6, y + 2, 4, 10, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 6, y + 12, 2, 2, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x + 10, y + 4, 2, 6, {color[1], color[2], color[3], color[4]}, true)
    renderer.rectangle(x, y + 4, 2, 2, {254, 199, 199, color[4]}, true)
end

local function text_shadow(x, y, string, r, g, b, a)
    draw.Color(0, 0, 0, a)
    draw.Text(x + 1, y + 1, string)
    draw.Color(r, g, b, a)
    draw.Text(x, y, string)
end

local font = draw.CreateFont("Segoe UI", 30, 20000)
local function on_draw()
    draw.SetFont(font)

    if not hit_effects then
        goto EndFrame
    end

    lp = entities_GetLocalPlayer()
    if lp then
        local players = entities_FindByClass("CCSPlayer")

        for i = 1, #players do
            local player = players[i]

            if table_active_hits[player:GetIndex()] then
                if table_active_hits[player:GetIndex()]["latest"] then
                    local latest = table_active_hits[player:GetIndex()]["latest"]

                    latest.liferemaining = latest.liferemaining - globals_FrameTime()

                    if latest.liferemaining <= 0.0 then
                        latest.liferemaining = 0
                        table_active_hits[player:GetIndex()]["latest"] = nil
                    end
                end

                for j = 1, #table_active_hits[player:GetIndex()] do
                    local current_hit = table_active_hits[player:GetIndex()][j]

                    if current_hit then
                        current_hit.liferemaining = current_hit.liferemaining - globals_FrameTime()
                        if current_hit.liferemaining <= 0.0 then
                            current_hit.liferemaining = 0
                            table_remove(table_active_hits[player:GetIndex()], j)
                        end
                    else
                        goto EndHit
                    end

                    local alpha = 255

                    if current_hit.liferemaining <= 3 then
                        alpha = math_floor(map(current_hit.liferemaining, 3, 0, 255, 0))
                    end

                    local draw_pos = vector2(client_WorldToScreen(current_hit.textpos))

                    if draw_pos.x then
                        draw_pos.x = draw_pos.x + (current_hit.textvel.x * 25) * (3 - current_hit.liferemaining)
                        draw_pos.y = draw_pos.y + (current_hit.textvel.y * 25) * (3 - current_hit.liferemaining)

                        renderer.love(draw_pos.x, draw_pos.y * 0.98, {255, 0, 0, alpha})
                    end
                    ::EndHit::
                end
            end
        end
        table_impacts = {}
    end
    ::EndFrame::
end

local function fire_game_event(game_event)
    local event_name = game_event:GetName()

    if event_name == "player_hurt" then
        local attacker = entities_GetByUserID(game_event:GetInt("attacker"))
        local victim = entities_GetByUserID(game_event:GetInt("userid"))
        local event_damage = game_event:GetInt("dmg_health")
        local event_hit_group = game_event:GetInt("hitgroup") + 1

        if attacker and victim and attacker:GetIndex() == lp:GetIndex() and attacker:GetIndex() ~= victim:GetIndex() then
            local victim_index = victim:GetIndex()
            local event_hit_box_pos = victim:GetHitboxPosition(hit_group_to_box[event_hit_group])
            local text_velocit = random_vector(30)
            local event_impact_pos

            if event_hit_group == 1 then
                event_impact_pos = victim:GetHitboxPosition("Stomach")
            else
                event_impact_pos = get_closest_impact(event_hit_box_pos)
            end

            local skeleton = {}

            if
                event_hit_group ~= 1 and (gui.GetValue("rbot.master") and gui.GetValue("rbot.accuracy.posadj.backtrack")) or
                    (gui.GetValue("lbot.master") and gui.GetValue("lbot.extra.backtrack") ~= 0)
             then
                skeleton = get_closest_back_track(event_impact_pos, victim_index, hit_group_to_box[event_hit_group])
            else
                skeleton = table_player_historys[victim_index][#table_player_historys[victim_index]].skeleton
            end

            local event_hit = Hit:create(event_damage, event_hit_group, event_impact_pos, skeleton, text_velocit)

            if not table_active_hits[victim_index] then
                table_active_hits[victim_index] = {}
            end

            table_insert(table_active_hits[victim_index], event_hit)
        end
    elseif event_name == "bullet_impact" then
        local attacker = entities_GetByUserID(game_event:GetInt("userid"))
        local impactPos = Vector3(game_event:GetFloat("x"), game_event:GetFloat("y"), game_event:GetFloat("z"))

        if attacker and attacker:GetIndex() == lp:GetIndex() then
            table_insert(table_impacts, impactPos)
        end
    elseif event_name == "round_prestart" then
        table_player_historys = {}
        table_active_hits = {}
        table_impacts = {}
    end
end

local function create_move()
    local lp = entities_GetLocalPlayer()
    local players = entities_FindByClass("CBasePlayer")

    for i = 1, #players do
        local player = players[i]
        local playerIndex = player:GetIndex()

        if player:GetTeamNumber() ~= lp:GetTeamNumber() and player:IsAlive() then
            local hitBoxes = {}
            for index = 0, 19 do
                local vec = player:GetHitboxPosition(index)
                table_insert(hitBoxes, vec)
            end

            if not table_player_historys[playerIndex] then
                table_player_historys[playerIndex] = {}
            end

            table_insert(table_player_historys[playerIndex], {skeleton = hitBoxes, expires = globals_CurTime() + 0.3})

            for index = 1, #table_player_historys[playerIndex] do
                if table_player_historys[playerIndex][index] then
                    local expires = table_player_historys[playerIndex][index].expires

                    if expires <= globals_CurTime() then
                        table_remove(table_player_historys[playerIndex], index)
                    end
                end
            end
        end
    end
end

client_AllowListener("player_hurt")
client_AllowListener("bullet_impact")
client_AllowListener("round_prestart")

callbacks.Register("CreateMove", create_move)
callbacks.Register("FireGameEvent", fire_game_event)
callbacks.Register("Draw", on_draw)






--***********************************************--

print("♥♥♥ " .. GetScriptName() .. " loaded without Errors ♥♥♥")

